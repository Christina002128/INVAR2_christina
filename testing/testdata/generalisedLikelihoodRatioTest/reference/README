Taken reference from processing the files
output_R/os/PARADIGM.f0.9_s2.BQ_20.MQ_40.SLX-19721_SXTLI001.1.ptspec.0.05.combined.polished.size.os.Rdata
and output_R/PARADIGM.f0.9_s2.BQ_20.MQ_40.size_characterisation.rds
through GLRT_iterate_nonptspec.R and doing what the collection code does,
namely looking for the lines with "INVAR_SCORE" in them (yes, really).

The code should be run with:

Rscript R/GLRT_iterate_nonptspec.R | tee GLRT.out

The "testdata" directory has three files "reorganiseInvarScores.*".

The GLRT.out file from above should be processed with the .sh version,
with five parameters.

1. The path to "GLRT.out" from above.
2. The path to the layout file.
3. The pool (SLX) number.
4. The barcode.

The shell script uses first the Python script to untangle the output
lines and then the R script to standardise and arrange the file.

For example:

../../reorganiseInvarScores.sh GLRT.PARA_028.out ../../invar_source/combined.SLX_table_with_controls_031220.v2.csv SLX-19721 SXTLI001
../../reorganiseInvarScores.sh GLRT.PARA_002.out ../../invar_source/combined.SLX_table_with_controls_031220.v2.csv SLX-19721 SXTLI001

The script will produce files
REFERENCE_invar_scores.<pool>.<barcode>.<patient>.rds
REFERENCE_invar_scores.<pool>.<barcode>.<patient>.tsv
REFERENCE_invar_scores.<pool>.<barcode>.<patient>.trimmed.tsv

The trimmed version is only iteration one of the GLRT algorithm, which
has no sampling and is therefore reproduceable. It will be the same
when the GLRT algorithm ran on the patient specific mutations.


Note: there is a bug in GLRT_iterate_nonptspec.R: it prints the with size
null and alt likelihoods for both rows. So the likelihoods for the execution
without size is wrong.

